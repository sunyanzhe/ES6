<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数组的解构赋值</title>
</head>
<body>
    <script>
        //ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被成为解构(Destructuring)

        //ES允许写成下面这样 
        let [a,b,c]=[1,2,3];
        console.log(a);     //1

        let [head,...tail]=[1,2,3,4];
        console.log(head);      //1
        console.log(tail);      //[2,3,4]

        //如果解构不成功，变量的值就等于undefined。
        let [foo]=[];
        console.log(foo);       //undefined;

        //另一种情况是不完全解析，即等号左边的模式只匹配一部分的等号右边的数组。这种情况下解构依然可以成功
        let [x,y]=[1,2,3];

        //如果等号的右边不是数组(或者严格来说不是可遍历的解构，参见第15章)，那么将会报错。
        //let [foo]=1;
        //let [foo]=false;
        //let [foo]=NaN;
        //let [foo]=undefined;
        //let [foo]=null;
        //let [foo]={};

        //上面的语句都会报错，因为等号右边的值或是转为对象以后不具备Iterator接口(前五个表达式)，或是本身就不具备Iterator接口(最后一个表达式)。
        
        //事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值
        function* fibs(){
            let a=0;
            let b=1;
            while(true){
                yield a;
                [a,b]=[b,a+b];
            }
        }
        
        let [first,second,third,fourth,fifth,sixth]=fibs();
        console.log(sixth);
        
        //上面的代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口中获取值。

        //3.1.2默认值
        //解构赋值允许指定默认值
        let [foo1=true]=[];
        console.log(foo1);      //true
        
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>12.2Proxy实例的方法</title>
</head>
<body>
    <script>
    //12.2 Proxy实例的方法
    //下面是上述拦截方法的详细介绍

        //12.2.1 get()
        //get方法用于拦截某个属性的读取操作,前面已经有一个例子,下面是另一个拦截读取操作的例子
        var person={
            name:'张三'
        }

        var proxy=new Proxy(person,{
            get(target,key,receiver){
                if(key in target) return target[key];
                throw new ReferenceError(`Property ${key} does not exist.`)
            }
        })

        console.log(proxy.name);        //张三
        //console.log(proxy.age);         //抛出错误
        
        //上面的代码表示,如果访问目标对象不存在的属性,会抛出一个错误,如果没有这个拦截函数,访问不存在的属性只会返回undefined

        //get方法可以继承
        var proto=new Proxy({},{
            get(target,key,receiver){
                console.log(`GET ${key}`);
                return target[key]
            }
        })
        
        var obj=Object.create(proto);
        console.log(obj.xxx);       //'Get XXX'   undefined

        //上面的代码中,拦截定义在Prototype对象上,所以如果读取obj对象继承的属性,拦截会生效
        //下面的例子使用get拦截实现数组读取负数索引
        function createArray(...elements){
            let handler={
                get(target,key,receiver){
                    let index=Number(key);
                    if(index<0)  key=String(target.length+index);
                    return Reflect.get(target,key,receiver)
                }
            }
            let target=[];
            target.push(...elements);
            return new Proxy(target,handler);
        }

        var arr=createArray('a','b','c')
        console.log(arr[-1]);           //c

        //上面的代码中,如果数组的位置参数是-1,就会输出数组的最后一个成员
        //利用Proxy,可以将读取属性的操作(get)转变为执行某个函数,从而实现属性的链式操作

        var pipe=(function(){
            return function(value){
                var funcStack=[];
                var proxy=new Proxy({},{
                    get(target,key){
                        if(key==='get'){
                           return funcStack.reduce((val,fn)=>fn(val),value);
                        }
                        funcStack.push(window[key]);
                        return proxy;

                    }
                })
                return proxy;
            }
        })();

        var double=n=>n*2;
        var pow=n=>n*n;
        var reverseInt=n=>Number(n.toString().split('').reverse().join(''))|0
        
        console.log(pipe(3).double.pow.reverseInt.get);  //63

        //上面的代码设置Proxy后达到了链式使用函数名的效果
        //下面的例子则是利用get拦截实现一个生成各种DOM节点的通用函数dom.
        const dom=new Proxy({},{
            get(target,key){
                return function(attrs={},...children){
                    const el=document.createElement(key);
                    for(let prop of Object.keys(attrs)){
                        el.setAttribute(prop,attrs[prop]);
                    }
                    for(let child of children){
                        if(typeof child === 'string'){
                            child=document.createTextNode(child);
                        }
                        el.appendChild(child);
                    }
                    return el;
                }
            }
        })

        const el=dom.div({},
            'Hello, my name is ',
            dom.a({href:'//example.com'},'Mark'),
            '. I like:',
            dom.ul({},
                dom.li({},'the web'),
                dom.li({},'Food'),
                dom.li({},'that\'s it')
            )
        )
        document.body.appendChild(el);

        //12.2.2 set()
        //set方法用于拦截某个属性的赋值操作
        //假定Person对象有一个age属性,该属性应该是一个不大于200的证书,那么可以使用Proxy对象保证age的属性值符合要求
        let validator={
            set:function(obj,prop,value){
                if(prop==='age'){
                    if(!Number.isInteger(value)){
                        throw new TypeError('The age is not an interger!');
                    }
                    if(value>200){
                        throw new RangeError('The age seems invalid');
                    }
                }
                //对于age以外的属性,直接保存
                obj[prop]=value;
            }
        };

        let person1=new Proxy({},validator);
        person1.age=100;
        console.log(person1.age);    //100
        // person1.age='youngs'     //报错
        // person1.age=300;         //报错

        //上面的代码中,由于设置了存值函数set,任何不符合要求的age属性赋值都会抛出一个错误,这是数据验证的一种实现方法.
        //利用set方法还可以实现数据绑定,即每当对象发生变化时,会自动更新DOM

        //有时,我们会在对象上设置内部方法,属性名的第一个字符使用下划线开头,表示这些属性不应该被外不要使用.
        //结合get和set方法,就可以做到防止这些内部属性被外部读/写

        var handler1={
            get(target,key){
                invariant(key,'get');
                return target[key];
            },
            set(target,key,value){
                invariant(key,'set');
                target[key]=value;
            }
        };
        function invariant(key,action){
            if(key.charAt(0)==='_'){
                throw new Error(`Invalid attempt to ${action} private "${key}" property`);
            }
        }
        
        var target={};
        var proxy=new Proxy(target,handler1);
        // proxy._prop;
        //Error:Invalid attempt to get private "_prop" property
        // proxy._prop='c';
        //Error:Invalid attempt to set private "_prop" property


        //上面的代码中,只要读/写的属性名的第一个字符是下划线,一律抛出错误,从而达到禁止读/写内部属性的目的

        
        /*
        *注意:如果目标对象自身的某个属性不可写也不可配置,那么set不得改变这个属性的值,只能返回相同的值,否则报错
        */

        //12.2.3 apply()
        //apply方法拦截函数的调用/call/apply操作
        
        //apply方法可以接受3个参数,分别是目标对象,目标对象的上下文对象(this)和目标对象的参数数组;
        // var handler={
        //     apply(target,ctx,args){
        //         return Reflect.apply(...arguments);
        //     }
        // };
        
        //下面是一个例子
        var target=function(){return `I'am a target!`};
        var handler2={
            apply(){
                return `I'm the proxy`;
            }
        }
        let p=new Proxy(target,handler2);
        console.log(p());       //I'm the proxy

        //上面的代码中,变量p是Proxy实例,作为函数调用时(p())就会被apply方法拦截,返回一个字符串.

        //下面是另一个例子
        var twice={
            apply(target,ctx,args){
                return Reflect.apply(...arguments)*2
            }
        };
        function sum(left,right){
            return left+right;
        }
        let p2=new Proxy(sum,twice);
        console.log(p2(1,2));               //6
        console.log(p2.call(null,5,6));     //22
        console.log(p2.apply(null,[7,8]));  //30

        //上面的代码中,每当执行了proxy函数(直接调用或call和apply调用)就会被apply方法拦截
        //另外,直接调用Reflect.apply方法也会被拦截
        //Reflect.apply(proxy,null,[9,10])    //38

        //12.2.4 has()
        //has方法用来拦截HasProperty操作,即判断对象是否具备某个属性时,这个方法会生效.经典的操作就是in运算符
        //下面的例子使用has方法隐藏了某些属性,使其不被in运算符发现
        var handler3={
            has(target,key){
                if(key.charAt(0)=="_"){
                    return false
                }else{
                    return key in target;
                }
            }
        };
        var target={_prop:'foo',prop:'foo'};
        var proxy=new Proxy(target,handler3);
        console.log('_prop' in proxy);       //false

        //上面代码中,如果原对象的属性名的第一个字符是下划线,proxy.has就会返回false,从而不会被in运算符发现

        //如果原对象不可配置或禁止扩展,那么这时has拦截就会报错;
        var obj={a:10};
        Object.preventExtensions(obj);

        var p3=new Proxy(obj,{
            has(target,prop){
                return false;
            }
        });
        //'a' in p3

        //上面的代码中,obj对象禁止扩展,结果适用has拦截就会报错.
        //也就是说,如果某个属性不可配置(或者目标对象不可扩展),则has方法就不得'隐藏'(即返回false)目标对象的该属性

        /**
        **has方法拦截的是HasProperty操作,而不是HasOwnProperty操作,即has方法不判断一个属性是对象自身还是继承的属性
        **/

        //另外,虽然for...in循环也用到了in运算符,但是has拦截对for...in循环不生效
    </script>
</body>
</html>
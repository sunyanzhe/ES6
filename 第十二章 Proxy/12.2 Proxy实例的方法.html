<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>12.2Proxy实例的方法</title>
</head>
<body>
    <script>
    //12.2 Proxy实例的方法
    //下面是上述拦截方法的详细介绍

        //12.2.1 get()
        //get方法用于拦截某个属性的读取操作,前面已经有一个例子,下面是另一个拦截读取操作的例子
        var person={
            name:'张三'
        }

        var proxy=new Proxy(person,{
            get(target,key,receiver){
                if(key in target) return target[key];
                throw new ReferenceError(`Property ${key} does not exist.`)
            }
        })

        console.log(proxy.name);        //张三
        //console.log(proxy.age);         //抛出错误
        
        //上面的代码表示,如果访问目标对象不存在的属性,会抛出一个错误,如果没有这个拦截函数,访问不存在的属性只会返回undefined

        //get方法可以继承
        var proto=new Proxy({},{
            get(target,key,receiver){
                console.log(`GET ${key}`);
                return target[key]
            }
        })
        
        var obj=Object.create(proto);
        console.log(obj.xxx);       //'Get XXX'   undefined

        //上面的代码中,拦截定义在Prototype对象上,所以如果读取obj对象继承的属性,拦截会生效
        //下面的例子使用get拦截实现数组读取负数索引
        function createArray(...elements){
            let handler={
                get(target,key,receiver){
                    let index=Number(key);
                    if(index<0)  key=String(target.length+index);
                    return Reflect.get(target,key,receiver)
                }
            }
            let target=[];
            target.push(...elements);
            return new Proxy(target,handler);
        }

        var arr=createArray('a','b','c')
        console.log(arr[-1]);           //c

        //上面的代码中,如果数组的位置参数是-1,就会输出数组的最后一个成员
        //利用Proxy,可以将读取属性的操作(get)转变为执行某个函数,从而实现属性的链式操作

        var pipe=(function(){
            return function(value){
                var funcStack=[];
                var proxy=new Proxy({},{
                    get(target,key){
                        if(key==='get'){
                           return funcStack.reduce((val,fn)=>fn(val),value);
                        }
                        funcStack.push(window[key]);
                        return proxy;

                    }
                })
                return proxy;
            }
        })();

        var double=n=>n*2;
        var pow=n=>n*n;
        var reverseInt=n=>Number(n.toString().split('').reverse().join(''))|0
        
        console.log(pipe(3).double.pow.reverseInt.get);  //63

        //上面的代码设置Proxy后达到了链式使用函数名的效果
        //下面的例子则是利用get拦截实现一个生成各种DOM节点的通用函数dom.
        const dom=new Proxy({},{
            get(target,key){
                return function(attrs={},...children){
                    const el=document.createElement(key);
                    for(let prop of Object.keys(attrs)){
                        el.setAttribute(prop,attrs[prop]);
                    }
                    for(let child of children){
                        if(typeof child === 'string'){
                            child=document.createTextNode(child);
                        }
                        el.appendChild(child);
                    }
                    return el;
                }
            }
        })

        const el=dom.div({},
            'Hello, my name is ',
            dom.a({href:'//example.com'},'Mark'),
            '. I like:',
            dom.ul({},
                dom.li({},'the web'),
                dom.li({},'Food'),
                dom.li({},'that\'s it')
            )
        )
        document.body.appendChild(el);
    </script>
</body>
</html>